#!/usr/bin/env ruby
# -*- ruby -*-

module Ocra
  Signature = [0x41, 0xb6, 0xba, 0x4e]
  OP_END = 0
  OP_CREATE_DIRECTORY = 1
  OP_CREATE_FILE = 2
  OP_CREATE_PROCESS = 3
  OP_DECOMPRESS_LZMA = 4
  OP_SETENV = 5
  OP_POST_CREATE_PROCESS = 6

  VERSION = "1.1.5.pre2"

  IGNORE_MODULES = /^enumerator.so$/

  IGNORE_GEMFILES = %r{(
    # Auxiliary files in the root of the gem
    ^(History|Install|Manifest|README|Licen[sc]e).(txt|rdoc)$ |
    # Installation files in the root of the gem
    ^(Rakefile|setup.rb|extconf.rb)$ |
    # Documentation/test directories in the root of the gem
    ^(doc|ext|examples|test|tests|benchmarks)\/ |
    # Directories anywhere
    (^|\/)(\.autotest|\.svn\.cvs)(\/|$) |
    # Unlikely extensions
    \.(rdoc)$/
  )}xi

  PATH_SEPARATOR = /[\/\\]/

  TEMPDIR_MARKER = "\xFF"

  class << self
    attr_accessor :lzma_mode
    attr_accessor :extra_dlls
    attr_accessor :files
    attr_accessor :load_autoload
    attr_accessor :force_windows
    attr_accessor :force_console
    attr_accessor :icon_filename
    attr_accessor :quiet
    attr_accessor :autodll
    attr_accessor :show_warnings
    attr_accessor :gem_filter
    
    attr_reader :lzmapath
    attr_reader :ediconpath
    attr_reader :stubimage
    attr_reader :stubwimage
    
    def get_next_embedded_image
      DATA.read(DATA.readline.to_i).unpack("m")[0]
    end
  end

  def Ocra.initialize_ocra
    save_environment
    find_stubs
  end

  def Ocra.save_environment
    @load_path_before = $LOAD_PATH.dup
    @pwd_before = Dir.pwd
    @env_before = {}; ENV.each { |key, value| @env_before[key] = value }
  end

  def Ocra.restore_environment
    @env_before.each { |key, value| ENV[key] = value }
    ENV.each_key { |key| ENV.delete(key) unless @env_before.has_key?(key) }
    Dir.chdir @pwd_before
  end

  def Ocra.find_stubs
    if defined?(DATA)
      @stubimage = get_next_embedded_image
      @stubwimage = get_next_embedded_image
      lzmaimage = get_next_embedded_image
      @lzmapath = File.join(ENV['TEMP'], 'lzma.exe').tr('/','\\')
      File.open(@lzmapath, "wb") { |file| file << lzmaimage }
      ediconimage = get_next_embedded_image
      @ediconpath = File.join(ENV['TEMP'], 'edicon.exe').tr('/','\\')
      File.open(@ediconpath, "wb") { |file| file << ediconimage }
    else
      ocrapath = File.dirname(__FILE__)
      @stubimage = File.open(File.join(ocrapath, '../share/ocra/stub.exe'), "rb") { |file| file.read }
      @stubwimage = File.open(File.join(ocrapath, '../share/ocra/stubw.exe'), "rb") { |file| file.read }
      @lzmapath = File.expand_path('../share/ocra/lzma.exe', ocrapath).tr('/','\\')
      @ediconpath = File.expand_path('../share/ocra/edicon.exe', ocrapath).tr('/','\\')
    end
  end

  def Ocra.parseargs(argv)
    lzma_mode = true
    extra_dlls = []
    files = []
    load_autoload = true
    force_windows = false
    force_console = false
    icon_filename = nil
    quiet = false
    autodll = true
    show_warnings = true
    gem_filter = true
    
    usage = <<EOF
ocra [options] script.rb

--dll dllname    Include additional DLLs from the Ruby bindir.
--no-lzma        Disable LZMA compression of the executable.
--quiet          Suppress output.
--help           Display this information.
--windows        Force Windows application (rubyw.exe)
--console        Force console application (ruby.exe)
--no-autoload    Don't load/include script.rb's autoloads
--icon <ico>     Replace icon with a custom one
--version        Display version number
--no-gem-filter  Don't filter readme's, doc, C-source, etc. from gems
EOF

    while arg = argv.shift
      case arg
      when /\A--(no-)?lzma\z/
        lzma_mode = !$1
      when /\A--dll\z/
        extra_dlls << argv.shift
      when /\A--quiet\z/
        quiet = true
      when /\A--windows\z/
        force_windows = true
      when /\A--console\z/
        force_console = true
      when /\A--no-autoload\z/
        load_autoload = false
      when /\A--icon\z/
        icon_filename = argv.shift
        raise "Icon file #{icon_filename} not found.\n" unless File.exist?(icon_filename)
      when /\A--no-autodll\z/
        autodll = false
      when /\A--version\z/
        puts "Ocra #{VERSION}"
        exit
      when /\A--no-warnings\z/
        show_warnings = false
      when /\A--no-gem-filter\z/
        gem_filter = false
      when /\A--help\z/, /\A--/
        puts usage
        exit
      else
        files << arg
      end
    end

    if files.empty?
      puts usage
      exit
    end

    @lzma_mode = lzma_mode
    @extra_dlls = extra_dlls
    @quiet = quiet
    @force_windows = force_windows
    @force_console = force_console
    @load_autoload = load_autoload
    @icon_filename = icon_filename
    @autodll = autodll
    @files = files
    @show_warnings = show_warnings
    @gem_filter = gem_filter
  end

  def Ocra.init(argv)
    save_environment
    parseargs(argv)
    initialize_ocra
  end

  # Force loading autoloaded constants. Searches through all modules
  # (and hence classes), and checks their constants for autoloaded
  # ones, then attempts to load them.
  def Ocra.attempt_load_autoload
    modules_checked = []
    loop do
      modules_to_check = []
      ObjectSpace.each_object(Module) do |mod|
        modules_to_check << mod unless modules_checked.include?(mod)
      end
      break if modules_to_check.empty?
      modules_to_check.each do |mod|
        modules_checked << mod
        mod.constants.each do |const|
          if mod.autoload?(const)
            begin
              mod.const_get(const)
            rescue NameError
              puts "=== WARNING: #{mod}::#{const} was defined autoloadable, but caused NameError" if Ocra.show_warnings
            rescue LoadError
              puts "=== WARNING: #{mod}::#{const} was not loadable" if Ocra.show_warnings
            end
          end
        end
      end
    end
  end

  def Ocra.relative_path(src, tgt)
    a = src.split('/')
    b = tgt.split('/')
    while a.first && a.first.downcase == b.first.downcase
      a.shift
      b.shift
    end
    return tgt if b.first =~ /^[a-z]:/i
    a.size.times { b.unshift '..' }
    return b.join('/')
  end

  # Determines if 'src' is contained in 'tgt' (i.e. it is a subpath of
  # 'tgt'). Both must be absolute paths and not contain '..'
  def Ocra.subpath?(src, tgt)
    src_normalized = src.tr('/','\\')
    tgt_normalized = tgt.tr('/','\\')
    src_normalized =~ /^#{Regexp.escape tgt_normalized}[\/\\]/i
  end

  def Ocra.find_load_path(paths, path)
    if path[1,1] == ":"
      rps = paths.map {|p| relative_path(File.expand_path(p), path) }
      rps.zip(paths).sort_by {|x| x[0].size }.first[1]
    else
      candidates = paths.select { |p| File.exist?(File.expand_path(path, p)) }
      candidates.sort_by {|p| p.size}.last
    end
  end
  
  def Ocra.build_exe
    @added_load_paths = $LOAD_PATH - @load_path_before

    restore_environment
    
    # Attempt to autoload libraries before doing anything else.
    attempt_load_autoload if Ocra.load_autoload

    # Store the currently loaded files (before we require rbconfig for
    # our own use).
    features = $LOADED_FEATURES.dup

    # Find gemspecs to include
    if defined?(Gem)
      gemspecs = Gem.loaded_specs.map { |name,info| info.loaded_from }
    else
      gemspecs = []
    end

    require 'rbconfig'
    exec_prefix = RbConfig::CONFIG['exec_prefix']
    src_prefix = Dir.pwd
    sitelibdir = RbConfig::CONFIG['sitelibdir']
    bindir = RbConfig::CONFIG['bindir']
    libruby_so = RbConfig::CONFIG['LIBRUBY_SO']

    # Find the root of all files specified on the command line and use
    # it as the "src" of the output. Adjust 'Ocra.files' to be
    # relative to the resulting root.
    files = Ocra.files.map { |file| Dir[file.tr('\\','/')] }.flatten
    files = files.map { |file| File.expand_path(file) }
    src_prefix = files.inject(File.dirname(files[0])) do |srcroot, path|
      if subpath?(path, exec_prefix)
        srcroot
      else
        loop do
          relpath = relative_path(srcroot, path)
          if relpath =~ /^[A-Z]:$/i
            puts "ERROR: No common directory contains all specified files"
          end
          if relpath =~ /^\.\.\//
            srcroot = File.dirname(srcroot)
          else
            break
          end
        end
        srcroot
      end
    end
    files = files.map { |file| relative_path(src_prefix, file) }
    Ocra.files = files

    instsitelibdir = sitelibdir[exec_prefix.size+1..-1]

    load_path = []

    # Detect loaded gems and add additional gem files to the
    # executable. Ruby 1.8 provides Gem.loaded_specs to detect gems,
    # but this is empty with Ruby 1.9. So instead, we look for any
    # loaded file from a gem path.
    if defined?(Gem)
      gems = []
      features_from_gems = []
      features.each do |filename|
        if filename !~ /^[a-z]:/i
          filename = find_load_path($:, filename)
          next if filename.nil? # Could be enumerator.so
        end
        Gem.path.each do |gempath|
          geminstallpath = File.join(gempath, "gems")
          if subpath?(filename, geminstallpath)
            gemlocalpath = filename[geminstallpath.size+1..-1]
            fullgemname = gemlocalpath.split('/')[0]
            gems << [gempath, fullgemname]
            features_from_gems << filename
          end
        end
      end
      gems.sort!.uniq!
      gem_files = []
      gems.each do |gempath, fullgemname|
        gemspecpath = File.join(gempath, "specifications", fullgemname + ".gemspec")
        gemspecs << gemspecpath
        spec = Gem::Specification.load(gemspecpath)

        # Get list of files
        files = spec.files
        # Filter out some unlikely files (Readme, etc.)
        files = files.select { |filename| filename !~ IGNORE_GEMFILES } if Ocra.gem_filter
        # Find the full path
        files = files.map { |file| File.join(gempath, "gems", fullgemname, file) }
        # Filter out non-files
        files = files.select { |file| File.file?(file) }
        
        gem_files += files
      end
      gem_files.sort!.uniq!
      features -= features_from_gems
    else
      gem_files = []
    end
    
    # Find loaded files
    libs = []
    features.each do |filename|
      path = find_load_path($:, filename)
      if path
        if filename[1,1] == ":"
          filename = relative_path(File.expand_path(path), filename)
        end
        if filename =~ /^\.\.\//
          puts "=== WARNING: Detected a relative require (#{filename}). This is not recommended." if Ocra.show_warnings
        end
        fullpath = File.expand_path(filename, path)
        if subpath?(fullpath, exec_prefix)
          libs << [ fullpath, fullpath[exec_prefix.size+1..-1] ]
        elsif subpath?(fullpath, src_prefix)
          targetpath = "src/" + fullpath[src_prefix.size+1..-1]
          libs << [ fullpath, targetpath ]
          if not @added_load_paths.include?(path) and not load_path.include?(path)
            load_path << File.join(TEMPDIR_MARKER, File.dirname(targetpath))
          end
        elsif defined?(Gem) and gemhome = Gem.path.find { |pth| subpath?(fullpath, pth) }
          targetpath = File.join("gemhome", relative_path(gemhome, fullpath))
          libs << [ fullpath, targetpath ]
        else
          libs << [ fullpath, File.join(instsitelibdir, filename) ]
        end
      else
        puts "=== WARNING: Couldn't find #{filename}" unless filename =~ IGNORE_MODULES if Ocra.show_warnings
      end
    end

    # Add files from Gems
    gem_files.each do |gemfile|
      if subpath?(gemfile, exec_prefix)
        libs << [ gemfile, relative_path(exec_prefix, gemfile) ]
      elsif defined?(Gem) and gemhome = Gem.path.find { |pth| subpath?(gemfile, pth) }
        targetpath = File.join("gemhome", relative_path(gemhome, fullpath))
        libs << [ gemfile, targetpath ]
      else
        raise "Don't know where to put #{gemfile}"
      end
    end

    # Detect additional DLLs
    dlls = Ocra.autodll ? LibraryDetector.detect_dlls : []

    executable = File.basename(Ocra.files[0].sub(/(\.rbw?)?$/, '.exe'))

    windowed = (Ocra.files[0] =~ /\.rbw$/ || Ocra.force_windows) && !Ocra.force_console

    puts "=== Building #{executable}" unless Ocra.quiet
    OcraBuilder.new(executable, windowed) do |sb|
      # Add explicitly mentioned files
      files.each do |file|
        file = File.join(src_prefix, file)

        if subpath?(file, exec_prefix)
          target = relative_path(exec_prefix, file)
        elsif subpath?(file, src_prefix)
          target = File.join('src', relative_path(src_prefix, file))
        else
          target = File.join('src', File.basename(file))
        end

        target.tr!('/','\\')
        
        if File.directory?(file)
          sb.ensuremkdir(target)
        else
          sb.createfile(file, target)
        end
      end

      # Add the ruby executable and DLL
      if windowed
        rubyexe = (RbConfig::CONFIG['rubyw_install_name'] || "rubyw") + ".exe"
      else
        rubyexe = (RbConfig::CONFIG['ruby_install_name'] || "ruby") + ".exe"
      end
      sb.createfile(File.join(bindir, rubyexe), "bin\\" + rubyexe)
      if libruby_so
        sb.createfile(File.join(bindir, libruby_so), "bin\\#{libruby_so}")
      end

      # Add detected DLLs
      dlls.each do |dll|
        if subpath?(dll.tr('\\','/'), exec_prefix)
          target = dll[exec_prefix.size+1..-1]
        else
          target = File.join('bin', File.basename(dll))
        end
        sb.createfile(dll, target)
      end
      
      # Add extra DLLs
      Ocra.extra_dlls.each do |dll|
        sb.createfile(File.join(bindir, dll), File.join("bin", dll).tr('/','\\'))
      end
      
      # Add gemspec files
      gemspecs.each do |gemspec|
        if subpath?(gemspec, exec_prefix)
          path = gemspec[exec_prefix.size+1..-1]
          sb.createfile(gemspec, path.tr('/','\\'))
        elsif defined?(Gem) and gemhome = Gem.path.find { |pth| subpath?(gemspec, pth) }
          path = File.join('gemhome', relative_path(gemhome, gemspec))
          sb.createfile(gemspec, path.tr('/','\\'))
        else
          raise "#{gemspec} does not exist in the Ruby installation. Don't know where to put it."
        end
      end

      # Add loaded libraries
      libs.each do |path, target|
        sb.createfile(path, target.tr('/', '\\'))
      end

      # Set environment variable
      sb.setenv('RUBYOPT', ENV['RUBYOPT'] || '')
      sb.setenv('RUBYLIB', load_path.uniq.join(';'))
      sb.setenv('GEM_PATH', "#{TEMPDIR_MARKER}\\gemhome")

      # Launch the script
      sb.postcreateprocess(TEMPDIR_MARKER + "\\bin\\" + rubyexe, "#{rubyexe} \"\xff\\src\\" + Ocra.files[0].tr('/','\\') + "\"")
      
      puts "=== Compressing" unless Ocra.quiet or not Ocra.lzma_mode
    end
    puts "=== Finished building #{executable} (#{File.size(executable)} bytes)" unless Ocra.quiet
  end

  module LibraryDetector
    def LibraryDetector.loaded_dlls
      require 'Win32API'

      enumprocessmodules = Win32API.new('psapi', 'EnumProcessModules', ['L','P','L','P'], 'B')
      getmodulefilename = Win32API.new('kernel32', 'GetModuleFileName', ['L','P','L'], 'L')
      getcurrentprocess = Win32API.new('kernel32', 'GetCurrentProcess', ['V'], 'L')

      bytes_needed = 4 * 32
      module_handle_buffer = nil
      process_handle = getcurrentprocess.call()
      loop do
        module_handle_buffer = "\x00" * bytes_needed
        bytes_needed_buffer = [0].pack("I")
        r = enumprocessmodules.call(process_handle, module_handle_buffer, module_handle_buffer.size, bytes_needed_buffer)
        bytes_needed = bytes_needed_buffer.unpack("I")[0]
        break if bytes_needed <= module_handle_buffer.size
      end
      
      handles = module_handle_buffer.unpack("I*")
      handles.select{|x|x>0}.map do |h|
        str = "\x00" * 256
        r = getmodulefilename.call(h, str, str.size)
        str[0,r]
      end
    end

    def LibraryDetector.detect_dlls
      loaded = loaded_dlls
      exec_prefix = RbConfig::CONFIG['exec_prefix']
      loaded.select do |path|
        Ocra.subpath?(path.tr('\\','/'), exec_prefix) and
          File.basename(path) =~ /\.dll$/i and
          File.basename(path).downcase != RbConfig::CONFIG['LIBRUBY_SO'].downcase
      end
    end
  end
  
  class OcraBuilder
    def initialize(path, windowed)
      @paths = {}
      File.open(path, "wb") do |ocrafile|

        if windowed
          ocrafile.write(Ocra.stubwimage)
        else
          ocrafile.write(Ocra.stubimage)
        end
      end

      if Ocra.icon_filename
        system Ocra.ediconpath, path, Ocra.icon_filename
      end

      opcode_offset = File.size(path)

      File.open(path, "ab") do |ocrafile|
        
        if Ocra.lzma_mode
          @of = ""
        else
          @of = ocrafile
        end

        yield(self)

        if Ocra.lzma_mode
          begin
            File.open("tmpin", "wb") { |tmp| tmp.write(@of) }
            system("\"#{Ocra.lzmapath}\" e tmpin tmpout 2>NUL") or fail
            compressed_data = File.open("tmpout", "rb") { |tmp| tmp.read }
            ocrafile.write([OP_DECOMPRESS_LZMA, compressed_data.size, compressed_data].pack("VVA*"))
            ocrafile.write([OP_END].pack("V"))
          ensure
            File.unlink("tmpin") if File.exist?("tmpin")
            File.unlink("tmpout") if File.exist?("tmpout")
          end
        else
          ocrafile.write(@of) if Ocra.lzma_mode
        end

        ocrafile.write([OP_END].pack("V"))
        ocrafile.write([opcode_offset].pack("V")) # Pointer to start of opcodes
        ocrafile.write(Signature.pack("C*"))
      end
    end
    def mkdir(path)
      @paths[path.downcase] = true
      puts "m #{showtempdir path}" unless Ocra.quiet
      @of << [OP_CREATE_DIRECTORY, path].pack("VZ*")
    end
    def ensuremkdir(tgt)
      return if tgt == "."
      if not @paths[tgt.downcase]
        ensuremkdir(File.dirname(tgt))
        mkdir(tgt)
      end
    end
    def createfile(src, tgt)
      ensuremkdir(File.dirname(tgt))
      str = File.open(src, "rb") { |file| file.read }
      puts "a #{showtempdir tgt}" unless Ocra.quiet
      @of << [OP_CREATE_FILE, tgt, str.size, str].pack("VZ*VA*")
    end
    def createprocess(image, cmdline)
      puts "l #{showtempdir image} #{showtempdir cmdline}" unless Ocra.quiet
      @of << [OP_CREATE_PROCESS, image, cmdline].pack("VZ*Z*")
    end
    def postcreateprocess(image, cmdline)
      puts "p #{showtempdir image} #{showtempdir cmdline}" unless Ocra.quiet
      @of << [OP_POST_CREATE_PROCESS, image, cmdline].pack("VZ*Z*")
    end
    def setenv(name, value)
      puts "e #{name} #{showtempdir value}" unless Ocra.quiet
      @of << [OP_SETENV, name, value].pack("VZ*Z*")
    end
    def close
      @of.close
    end

    def showtempdir(x)
      x.gsub(TEMPDIR_MARKER, "<tempdir>")
    end
      
  end # class OcraBuilder
  
end # module Ocra

if File.basename(__FILE__) == File.basename($0)
  Ocra.init(ARGV)
  ARGV.clear

  if !File.exist?(Ocra.files[0])
    puts "ERROR: #{Ocra.files[0]} was not found!"
    exit
  end
  
  # # Confirm that the primary source file exists below the current
  # # directory.
  # main_script = File.expand_path(Ocra.files[0])
  # if !Ocra.subpath?(main_script, Dir.pwd)
  #   puts "ERROR: #{Ocra.files[0]} does not exist below the current directory. Please change the\n" \
  #   "current directory to the root of your source and resource files."
  #   exit
  # end

  at_exit do
    if $!.nil? or $!.kind_of?(SystemExit)
      Ocra.build_exe
      exit(0)
    end
  end

  puts "=== Loading script to check dependencies" unless Ocra.quiet
  $0 = Ocra.files[0]
  load Ocra.files[0]
end
